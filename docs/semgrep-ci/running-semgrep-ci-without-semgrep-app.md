---
slug: running-semgrep-ci-without-semgrep-app
append_help_link: true
title: Running Semgrep in CI without Semgrep App 
description: "This document guides you through setting up semgrep in continuous integration without connecting to Semgrep App."
tags:
    - Semgrep in CI
    - Community Tier
    - Team & Enterprise Tier
hide_title: true
---

import MoreHelp from "/src/components/MoreHelp"
import DiffAwareScanning from "/src/components/reference/_diff-aware-scanning.mdx"
import CiScheduling from "/src/components/reference/_ci-scheduling.mdx"
import CiIgnoringFiles from "/src/components/reference/_ci-ignoring-files.mdx"

<ul id="tag__badge-list">
{
Object.entries(frontMatter).filter(
    frontmatter => frontmatter[0] === 'tags')[0].pop().map(
    (value) => <li class='tag__badge-item'>{value}</li> )
}
</ul>

# Running Semgrep in continuous integration (CI) without Semgrep App

Run Semgrep in your Continuous Integration (CI) pipeline to scan your repository for code vulnerabilities and other issues. This guide explains how to set up Semgrep in your pipeline without the use of Semgrep App, also known as a **stand-alone** setup.

There are three general steps to setting up Semgrep in your CI pipeline:

1. Set up the CI job or action to scan with Semgrep and receive an exit code.
2. Test that the Semgrep job is scanning your repository and that you are able to view scan results in your CI provider's log.
3. Configure the CI job's parameters. It is easier to troubleshoot any parameters after testing that the job runs successfully.

![Steps to run Semgrep in CI without Semgrep App](/img/semgrep-ci-overview-noapp.png "Steps to integrate Semgrep in CI without Semgrep App")
*Figure 1. Steps to run Semgrep in CI without Semgrep App.*

This guide defines a job or CI job as a script executed within a certain environment and managed by a CI provider.

## Reasons for configuring additional CI job parameters

By configuring a job's parameters, you are able to achieve the following goals:

* **Run Semgrep on a schedule**. Run full scans on mainline branches at the least intrusive time on developer teams.
* **Run Semgrep with custom rules**. Apply rules specific to your organization's business goals and coding conventions.
* **Run Semgrep when an event triggers**. Run Semgrep when a pull or merge request (PR or MR) is created. These event triggers or event hooks are dependent on your CI provider. 
* **Run Semgrep on relevant files and blocks of code**. Configure Semgrep to ignore files and folders such as test files, configuration files, and files from other vendors.
* **Configure a Semgrep CI job to pass even when any finding is detected**. By default, stand-alone configurations fail when any finding is detected. You can also configure Semgrep to pass CI jobs when findings are reported.
* **Output, export, or save findings to a file**. Semgrep can save to a number of file formats, including SARIF and JSON.

## Limitations of stand-alone Semgrep CI scans 

Running Semgrep in CI without Semgrep App bears specific limitations compared to the use of Semgrep in CI with Semgrep App. See the following list:

* Stand-alone CI jobs cannot send [PR or MR comments](/semgrep-app/notifications/#enabling-github-pull-request-comments). These comments describe the finding and help developers resolve vulnerabilities and other code issues.
* Stand-alone CI jobs cannot block a pull or merge request based on a finding. There is no distinction or tiering between rules. Alternatively, Semgrep App's [Rule Board](/semgrep-app/rule-board) can tier rules and undertake actions, such as blocking PRs or MRs on a finding generated by a reliable rule.
* Findings are dumped to a log, so there is no record of a finding's **triage state**, such as opened, closed, or ignored.

:::note
`semgrep ci` prevents the duplication of findings by scanning only the changes in files in pull or merge requests. This is different from Semgrep App's capability to track a finding's **triage state**, as each finding has a record.
:::

## Setting up the CI job

 `semgrep ci` is the command used to run Semgrep in a CI environment. In most cases, this is the recommended command to run in the CI job. This command is a subset of the `semgrep scan` command. `semgrep ci` command has the following characteristics:
 
 * `semgrep ci` is git-aware. This means it is able to detect branches and git states. 
 * `semgrep ci` makes use of environment variables to configure its behavior. 
 * `semgrep ci` performs a full scan by default. This is the recommended behavior. Semgrep can be configured to perform a diff-aware scan.
 * `semgrep ci` can be run on a local `.git` repository at any time to test its behavior before running it within a CI environment.

### GitHub Actions

To add Semgrep into your GitHub Actions pipeline:

1. Create a `semgrep.yaml` configuration file to add a Semgrep command as part of your Github Actions pipeline. Refer to the [GitHub Actions code snippet](#github-actions-code-snippet).
2. Optional: Review the [GitHub Actions workflow syntax](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions) to help with editing the configuration file.
3. Commit the configuration file into the `.github/workflows` folder within the target repository. The Semgrep job starts automatically upon detecting the `semgrep.yaml` commit in the previous step
4. Optional: Re-run or view the job from the GitHub Actions interface.
5. Customize the job's behavior, such as its rules to scan and files to ignore.

:::note
If you are self-hosting your repository, you must [use a self-hosted runner](https://docs.github.com/en/actions/using-jobs/choosing-the-runner-for-a-job#choosing-self-hosted-runners).
:::

#### GitHub Actions code snippet

```yaml
# Name of this GitHub Actions workflow.
name: Semgrep

on:
  # Scan changed files in PRs (diff-aware scanning):
  pull_request: {}
  # Scan mainline branches and report all findings:
  push:
    branches: ["master", "main"]
  # Schedule the CI job (this method uses cron syntax):
  schedule:
    - cron: '30 0 1,15 * *' # Scheduled for 00:30 UTC on both the 1st and 15th of the month

jobs:
  semgrep:
    # User-definable name of this GitHub Actions job:
    name: Scan
    # If you are self-hosting, change the following `runs-on` value: 
    runs-on: ubuntu-latest

    container:
      # A Docker image with Semgrep installed. Do not change this.
      image: returntocorp/semgrep

    # To skip any PR created by dependabot to avoid permission issues:
    if: (github.actor != 'dependabot[bot]')

    steps:
      # Fetch project source with GitHub Actions Checkout.
      - uses: actions/checkout@v3
      # Run the "semgrep ci" command on the command line of the docker image.
      - run: semgrep ci
        env:
           # Add the rules that Semgrep uses by setting the SEMGREP_RULES environment variable. 
           SEMGREP_RULES: p/default # more at semgrep.dev/explore
           # Uncomment SEMGREP_TIMEOUT to set this job's timeout (in seconds):
           # Default timeout is 1800 seconds (30 minutes).
           # Set to 0 to disable the timeout.
           # SEMGREP_TIMEOUT: 300
```

### GitLab CI/CD

To add Semgrep into your GitLab CI/CD pipeline:

1. Create or edit a `.gitlab-ci.yml` configuration file to add a Semgrep
   command as part of your GitLab CI/CD pipeline. Refer to the [GitLab CI/CD code
   snippet](#gitlab-cicd-code-snippet).
2. Optional: Review the [GitLab configuration guide](https://docs.gitlab.com/ee/ci/yaml/gitlab_ci_yaml.html) to help with editing the configuration file. 
3. Commit the configuration file into the root folder within the target repository. The Semgrep job starts automatically upon detecting the `.gitlab-ci.yml` commit in the previous step.
4. Optional: Re-run or view the job from your GitLab project's **CI/CD > Pipelines page**.
5. Customize the job's behavior, such as its rules to scan and files to ignore.

:::note
If you are already running [GitLab SAST](https://docs.gitlab.com/ee/user/application_security/sast/) by including the template `Security/SAST.gitlab-ci.yml` in your CI/CD configuration, you can still include and customize Semgrep's CI integration. GitLab SAST, including its `semgrep-sast` analyzer, will continue to run normally. Refer to the [GitLab CI/CD with GitLab SAST snippet](#gitlab-cicd-with-gitlab-sast-snippet).
:::

#### GitLab CI/CD code snippet

```yaml
semgrep:
  # A Docker image with Semgrep installed.
  image: returntocorp/semgrep
  # Run the "semgrep ci" command on the command line of the docker image.
  script: semgrep ci

  rules:
    # Scan changed files in MRs (diff-aware scanning):
    - if: $CI_MERGE_REQUEST_IID
    # Scan all files on the default branch and report any findings:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

  variables:
    # Define rules to scan with by setting the SEMGREP_RULES environment variable. 
    SEMGREP_RULES: p/default
    # Uncomment SEMGREP_TIMEOUT to set this job's timeout (in seconds):
    # Default timeout is 1800 seconds (30 minutes).
    # Set to 0 to disable the timeout.
    # SEMGREP_TIMEOUT: 300
```

#### GitLab CI/CD code snipppet with GitLab SAST

```yaml
semgrep:
  # A Docker image with Semgrep installed.
  image: returntocorp/semgrep

  rules:
    # Scan changed files in MRs (diff-aware scanning):
    - if: $CI_MERGE_REQUEST_IID
    # Scan all files on the default branch and report any findings:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

  variables:
    # Add the rules that Semgrep uses by setting the SEMGREP_RULES environment variable. 
    SEMGREP_RULES: p/default # See more rules at semgrep.dev/explore.
    # Uncomment SEMGREP_TIMEOUT to set this job's timeout (in seconds):
    # Default timeout is 1800 seconds (30 minutes).
    # Set to 0 to disable the timeout.
    # SEMGREP_TIMEOUT: 300
    # Upload findings to GitLab SAST Dashboard
    SEMGREP_GITLAB_JSON: "1"
    script: semgrep ci --gitlab-sast > gl-sast-report.json || true
    artifacts:
      reports:
        sast: gl-sast-report.json
```

### Jenkins

:::note
Your UI (user interface) may vary depending on your Jenkins installation. These steps use a Classic UI Jenkins interface.
:::

To add Semgrep into your Jenkins pipeline:

1. Edit or create your `Jenkinsfile` configuration file to add a Semgrep `step` as part of your Jenkins Pipeline. Refer to the [Jenkins CI code snippet](#jenkins-ci-code-snippet). You can edit your `Jenkinsfile` from Jenkins's interface.
2. Optional: Review [`Jenkinsfile` usage](https://www.jenkins.io/doc/book/pipeline/jenkinsfile/) to help with editing the configuration file.
3. If you are using Jenkins Classic UI, save your [`Jenkinsfile`](https://www.jenkins.io/doc/book/pipeline/getting-started/#through-the-classic-ui) within the Jenkins interface. Otherwise, commit the configuration file into the root folder within the target repository. The Semgrep job starts automatically upon detecting the `Jenkinsfile` commit in the previous step. 
4. Optional: Re-run the stage from [Jenkins's interface](https://www.jenkins.io/doc/book/pipeline/running-pipelines/#restarting-from-the-classic-ui).
6. Customize the job's behavior, such as its rules to scan and files to ignore.

#### Jenkins CI code snippet

This code snippet uses Jenkins declarative syntax.

```javascript
pipeline {
  agent any
  stages {
    stage('Semgrep-Scan') {
        environment { 
          // Add the rules that Semgrep uses by setting the SEMGREP_RULES environment variable. 
          SEMGREP_RULES = "p/default"
          // Scan changed files in PRs or MRs (diff-aware scanning):
          // SEMGREP_BASELINE_REF = "${GIT_BRANCH}"
          // Uncomment SEMGREP_TIMEOUT to set this job's timeout (in seconds):
          // Default timeout is 1800 seconds (30 minutes).
          // Set to 0 to disable the timeout.
          // SEMGREP_TIMEOUT = "300"
        } 
      steps {
        sh 'pip3 install semgrep'
        sh 'semgrep ci'
      }
    }
  }
}
```

### BitBucket Pipelines

To add Semgrep into your BitBucket Pipeline:

1. Create or edit a `bitbucket-pipelines.yml` configuration file to add
   a Semgrep `step` as part of your pipeline. Refer to the [BitBucket Pipelines code snippet](#bitbucket-pipelines-code-snippet).
2. Optional: Review the [BitBucket guidelines](https://support.atlassian.com/bitbucket-cloud/docs/configure-bitbucket-pipelinesyml/) to help with editing the configuration file.
3. Commit the configuration file into the root folder within the target repository. The Semgrep job starts automatically upon detecting the `bitbucket-pipelines.yml` commit in the previous step.
4. Optional: Re-run or view the Pipeline by clicking from **your repository > Pipelines**.
5. Customize the job's behavior, such as its rules to scan and files to ignore.

:::note
These steps can also be performed through BitBucket's UI wizard. This UI wizard can be accessed through **BitBucket > your repository > Pipelines > Create your first pipeline**.
:::

#### BitBucket Pipelines code snippet

```yaml
image: atlassian/default-image:latest

pipelines:
  default:
    - parallel:
      - step:
        name: 'Run Semgrep scan with current branch'
        deployment: dev
        image: returntocorp/semgrep
        script:
          # Define rules to scan with by setting the SEMGREP_RULES environment variable. 
          - export SEMGREP_RULES="p/default" 
          # Scan changed files in PRs or MRs (diff-aware scanning):
          # - export SEMGREP_BASELINE_REF=$BITBUCKET_BRANCH
          # Uncomment SEMGREP_TIMEOUT to set this job's timeout (in seconds):
          # Default timeout is 1800 seconds (30 minutes).
          # Set to 0 to disable the timeout.
          # - export SEMGREP_TIMEOUT="300" 
          - semgrep ci
```

### CircleCI

To add Semgrep into your CircleCI pipeline:

1. Create or edit a `config.yml` configuration file to add a Semgrep command as
   part of your CircleCI workflow. Refer to the [CircleCI code snippet](#circleci-code-snippet).
2. Optional: Review the [CirclCI YAML introduction](https://circleci.com/docs/introduction-to-yaml-configurations) to help with editing the configuration file.
3. Commit the configuration file into the `/.circleci` folder within the target repository.
4. The Semgrep job starts automatically upon detecting the `config.yml` commit in the previous step.
5. Customize the job's behavior, such as its rules to scan and files to ignore.

#### CircleCI code snippet

```yaml
version: 2.1
jobs:
  semgrep-scan:
    parameters:
      default_branch:
        type: string
        default: main
    environment:
      # Define rules to scan with by setting the SEMGREP_RULES environment variable. 
      SEMGREP_RULES: p/default
      # Scan changed files in PRs or MRs (diff-aware scanning):
      # SEMGREP_BASELINE_REF: << parameters.default_branch >>
      # Uncomment SEMGREP_TIMEOUT to set this job's timeout (in seconds):
      # Default timeout is 1800 seconds (30 minutes).
      # Set to 0 to disable the timeout.
      # SEMGREP_TIMEOUT: 300

    docker:
      - image: returntocorp/semgrep
    steps:
      - checkout
      - run:
          name: "Semgrep scan"
          command: semgrep ci
workflows:
  main:
    jobs:
      - semgrep-scan
```

### Buildkite

To add Semgrep into your Buildkite pipeline:

1. Create or edit a `pipelines.yml` configuration file to add a Semgrep command as part of your pipeline. Refer to the [BuildKite code snippet](#buildkite-code-snippet). This configuration file can also be stored within Buildkite.
2. Optional: Review the [Buildkite steps definition](https://buildkite.com/docs/pipelines/defining-steps) to help with editing the configuration file.
3. If you are using Buildkite to store the configuration, save the file. Otherwise, commit the configuration file into the `/.buildkite` folder within the target repository.
4. The Semgrep job starts automatically upon detecting the `pipelines.yml` commit in the previous step.
5. Customize the job's behavior, such as its rules to scan and files to ignore.

:::note
These steps can be performed from within Buildkite's interface. From Buildkite's main page, click **Pipelines > âž• button** to perform these steps within Buildkite's UI.
:::

#### Buildkite code snippet

```yaml
- label: ":semgrep: Semgrep"
  commands:
    # Define rules to scan with by setting the SEMGREP_RULES environment variable. 
    - export SEMGREP_RULES="p/default"
    # To scan changed files in PRs or MRs (diff-aware scanning):
    # - export SEMGREP_BASELINE_REF=${BUILDKITE_BRANCH}
    # Uncomment SEMGREP_TIMEOUT to set this job's timeout (in seconds):
    # Default timeout is 1800 seconds (30 minutes).
    # Set to 0 to disable the timeout.
    # - export SEMGREP_TIMEOUT="300"
    - semgrep ci 
  
  plugins:
    - docker#v3.7.0:
      image: returntocorp/semgrep
```

### Running Semgrep through other CI providers

Use either of the following methods to run Semgrep through other CI providers.

#### Direct docker usage 

Reference or add the [returntocorp/semgrep](https://hub.docker.com/r/returntocorp/semgrep) Docker image directly. The method to add the Docker image varies based on the CI provider. This method is used in the [BitBucket Pipelines code snippet](#bitbucket-pipelines-code-snippet).

#### Install `semgrep` within your CI job

If you cannot use the Semgrep Docker image, install Semgrep as a step or command within your CI job:

1. Add `pip3 install semgrep` into the configuration file as a step or command, depending on your CI provider's syntax.
2. Run any valid `semgrep ci` command, such as `semgrep ci --config auto`.

This method is used in the [Jenkins CI code snippet](#jenkins-ci-code-snippet).

## Configuring the CI job

The following sections describe methods to customize your CI job.

### Passing or failing the CI job

By default, a Semgrep CI job exits with exit code 1 if the scan returns any findings. This causes the job to fail.

Semgrep provides **fail open** options. These options enable you to suppress findings that block your pipeline:

<dl>
	<dt><code>semgrep ci</code></dt>
	<dd><strong>Fail</strong> on blocking findings, but <strong>passes</strong> on internal errors. This is the default behavior.</dd>
	<dt><code>semgrep ci --no suppress errors</code></dt>
	<dd>The Semgrep CI job <strong>fails</strong> on blocking findings and on internal errors.</dd>
	<dt><code>semgrep ci || true</code></dt>
	<dd><strong>Pass</strong> on blocking findings and on internal errors.</dd>
</dl>

Refer to [Semgrep exit codes](/docs/cli-reference/#exit-codes) to understand various internal issues that cause Semgrep to fail.

### Diff-aware scanning

<DiffAwareScanning />

### Setting a scan schedule

<CiScheduling />

### Customizing rules and rulesets

#### Adding rules to scan with `semgrep ci`

`semgrep ci` accepts a list of rules and rulesets to run on each scan. The rules and rulesets can come from the [Semgrep Registry](https://semgrep.dev/explore/), or your own rules. The sources for rules to scan with are:

* A `.semgrep` folder located at the root of your repository.
* The value of the `SEMGREP_RULES` environment variable.

The `SEMGREP_RULES` environment variable accepts a list of local and remote rules and rulesets to run. The `SEMGREP_RULES` list is delimited by a space (` `) if the variable is exported from a shell command or script block. For example, see the following BitBucket Pipeline snippet:

```yaml
# ...
  script:
    - export SEMGREP_RULES="p/nginx p/ci no-exec.yml" 
    - semgrep ci
# ...
```

The line defining `SEMGREP_RULES` defines three different sources, delimited by a space:

```
- export SEMGREP_RULES="p/nginx p/ci no-exec.yml" 
```

The example references two rulesets from Semgrep Registry (`p/nginx` and `p/ci`) and a rule available in the repository (`no-exec.yml`).

If the `SEMGREP_RULES` environment variable is defined from a YAML block, the list of rules and rulesets to run is delimited by a newline. See the following example of a GitLab CI/CD snippet:
```YAML
# ...
variables:
  SEMGREP_RULES: >-
    p/nginx
    p/ci
    no-exec.yml
# ...
```

#### Writing your own rules

Write custom rules to enforce your team's coding standards and security practices. Rules can be forked from existing community-written rules.

See [Writing rules](https://semgrep.dev/docs/writing-rules/overview/) to learn how to write custom rules.

### Ignoring files

<CiIgnoringFiles />

### Saving or exporting findings to a file

To save or export findings, pass file format options and send the formatted findings to a file.

For example, to save to a JSON file:

`semgrep ci --json --output findings.json`

You can also use output redirection (`>`):

`semgrep ci --sarif > findings.sarif`

Refer to the [CLI reference](/cli-reference) for output formats.

## Migrating to Semgrep App from a stand-alone CI setup

Migrate to Semgrep App to:

* **View and manage findings in a centralized location**. False positives can be ignored through triage actions.These actions can be undertaken in bulk.
* **Configure rules and actions to undertake when a finding is generated by the rule**. You can undertake the following actions:
    * Audit the rule. This means that findings are kept within Semgrep's Findings page and are not surfaced to your team's SCM.
    * Show the finding to your team through the use of PR and MR comments.
    * Block the pull or merge request.

To migrate to Semgrep App:

1. Create an account in [Semgrep App](https://semgrep.dev/login).
2. Click **Projects > Scan New Project** and follow the steps in [Integrating Semgrep in CI providers with Semgrep App](/semgrep-app/getting-started-with-semgrep-app).
3. Optional: If you have previously set a custom `SEMGREP_TIMEOUT` environment variable, commit it to the CI configuration file created by Semgrep App. Do not copy `SEMGREP_RULES`.
4. Optional: Remove the old CI job that does not use Semgrep App.

<MoreHelp />
