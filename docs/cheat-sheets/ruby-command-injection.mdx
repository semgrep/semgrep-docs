---
slug: ruby-command-injection
description: "Command injection prevention cheat sheet for Ruby."
---

import LinkToRegistryRule from "/src/components/LinkToRegistryRule"
import CommandInjectionIntro from "/src/components/concept/_command-injection-intro.mdx"
import RecommendedRuleSet from "/src/components/code_snippets/_cheat-sheets-recommended-rule-set.mdx"

# Command injection prevention for Ruby

<CommandInjectionIntro />

### Check your project using Semgrep

<RecommendedRuleSet />

## 1. Running OS commands

### 1.A. Running code with Open3 module

`Open3` grants access to running processes when running another program. For more information, see [Ruby documentation](https://docs.ruby-lang.org/en/2.0.0/Open3.html). Such methods as `capture2`, `capture2e`, `capture3`, `popen2`, `popen2e`, `popen3`, `pipeline`, `pipeline_r`, `pipeline_rw`, `pipeline_start` and `pipeline_w` are intended for running commands provided as a string. Letting user supplied data in a command that is passed as an argument to one of these methods, can create an opportunity for a command injection vulnerability.

Example:

```ruby
require 'open3'

# safe
Open3.popen3("ls -la")

# vulnerable
user_input = "  && cat /etc/passwd" # Value supplied by user
Open3.popen3("ls #{user_input}")
```

```ruby
require 'open3'

# safe
fname = "/usr/share/man/man1/ls.1.gz"
Open3.pipeline(["zcat", fname], "nroff -man", "colcrt")

# vulnerable
user_input = "  && cat /etc/passwd" # Value supplied by user
Open3.pipeline("zcat #{user_input}‚Äù, "nroff -man", "colcrt")
```

#### References

- [`Open3` documentation](https://docs.ruby-lang.org/en/2.0.0/Open3.html)

#### Mitigation

- Do not pass user input to `Open3` methods.
- Always try to use internal Ruby API (if it exists) instead of running an OS command. In other words, use internal language features instead of invoking commands that can be exploited.
- Don't pass user-controlled input or use an allowlist for inputs.
- Do not include command arguments in a command string, use parameterization instead. For example:<br />
    Use:
    ```ruby
    Open3.pipeline(["/path/to/myCommand", "myArg1", input_value])
    ```
    Instead of:
    ```ruby
    Open3.pipeline(["bash", "-c", "myCommand myArg1 " + input_value])
    ```
- Define a list of allowed arguments.
- Avoid non-literal values for the command string. Strip everything except alphanumeric characters from an input provided for the command string and arguments.

#### Semgrep rule

<LinkToRegistryRule ruleId="ruby.lang.security.dangerous-open3-pipeline.dangerous-open3-pipeline" />

### 1.B. Using open() to run subprocesses

The `open(...)` creates an input/output (I/O) object connected to a stream, file, or subprocess. If the first argument starts with a pipe character (`|`), it creates a subprocess. An opportunity for command injection vulnerability is created when the subprocess includes user input in a command argument to `open()` function.

Example:

```ruby
# safe
open("my_file.txt")

# vulnerable
user_input = ‚Äú|cat /etc/passwd‚Äù # Value supplied by user
open(user_input)
```

#### References

- [`open()` documentation](https://apidock.com/ruby/Kernel/open)

#### Mitigation

- Do not provide raw user input to `open()` methods.
- Always try to use internal Ruby API (if it exists) instead of running an OS command. In other words, use internal language features instead of invoking commands that can be exploited.
- If the use of user input is unavoidable, create an allowlist for inputs, such as allowed arguments.
- Strip everything except alphanumeric characters from an input provided for the command string and arguments.

#### Semgrep rule

<LinkToRegistryRule ruleId="ruby.lang.security.dangerous-open.dangerous-open" />

### 1.C. Using system() to execute OS commands

The `system()` executes OS commands
TODO: https://apidock.com/ruby/Kernel/system

Example:

```ruby
# safe
system("ls -lah /tmp")

# vulnerable
user_input = ' && cat /etc/passwd' # Value supplied by user
system("ls #{user_input}")
```

#### References

- [`system()` documentation](https://apidock.com/ruby/Kernel/system)

#### Mitigation:

- Do not provide raw user input to `open` methods.
- Always try to use internal Ruby API (if it exists) instead of running an OS command. In other words, use internal language features instead of invoking commands that can be exploited.
- If the use of user input is unavoidable, create an allowlist for inputs, such as allowed arguments.
- Strip everything except alphanumeric characters from an input provided for the command string and arguments.

#### Semgrep rule

<LinkToRegistryRule ruleId="ruby.lang.security.dangerous-exec.dangerous-exec" />

### 1.D. Using exec() to execute OS commands

The `exec()` executes OS commands
TODO: https://apidock.com/ruby/Kernel/system

Example:

```ruby
# safe
exec("ls -lah /tmp")

# vulnerable
user_input = ' && cat /etc/passwd' # Value supplied by user
exec("ls #{user_input}")
```

#### References

- [`exec()` documentation](https://apidock.com/ruby/Kernel/exec)

#### Mitigation

- Do not provide raw user input to `open` methods.
- Always try to use internal Ruby API (if it exists) instead of running an OS command. In other words, use internal language features instead of invoking commands that can be exploited.
- If the use of user input is unavoidable, create an allowlist for inputs, such as allowed arguments.
- Strip everything except alphanumeric characters from an input provided for the command string and arguments.

#### Semgrep rule

<LinkToRegistryRule ruleId="ruby.lang.security.dangerous-exec.dangerous-exec" />

### 1.D. Using spawn() to execute OS commands

The `spawn()` executes OS commands
TODO: https://apidock.com/ruby/v2_5_5/Kernel/spawn

Example:

```ruby
# safe
pid = spawn("ls -lah /tmp")
Process.wait pid

# vulnerable
user_input = ' && cat /etc/passwd' # Value supplied by user
pid = spawn("ls #{user_input}")
Process.wait pid
```

#### References

- [`spawn()` documentation](https://apidock.com/ruby/Kernel/spawn)

#### Mitigation

- Do not provide raw user input to `open` methods.
- Always try to use internal Ruby API (if it exists) instead of running an OS command. In other words, use internal language features instead of invoking commands that can be exploited.
- If the use of user input is unavoidable, create an allowlist for inputs, such as allowed arguments.
- Strip everything except alphanumeric characters from an input provided for the command string and arguments.


#### Semgrep rule

<LinkToRegistryRule ruleId="ruby.lang.security.dangerous-exec.dangerous-exec" />

### 1.E. Using backticks (``) or %x to execute OS commands

copy-paste from docs:

Returns the $stdout output from running command in a subshell; sets global variable $? to the process status.
This method has potential security vulnerabilities if called with untrusted input; see Command Injection.

`command` (backtick method) (also called by the expression %x[command])
TODO: https://ruby-doc.org/3.2.1/Kernel.html
TODO: https://ruby-doc.org/3.2.1/command_injection_rdoc.html

Example:

```ruby
# safe
`ls -lah /tmp`

# from: https://stackoverflow.com/questions/6338908/ruby-difference-between-exec-system-and-x-or-backticks
# ü§Øü§Øü§Ø
%x[ ls -lah /tmp ]
%x{ ls -lah /tmp }

# vulnerable
user_input = ' && cat /etc/passwd' # Value supplied by user
`ls #{user_input}`

%x{ls #{user_input}}
```

#### References

- [Kernel documentation](https://ruby-doc.org/3.2.1/Kernel.html)

#### Mitigation

- Do not provide raw user input to `%x` methods.
- Always try to use internal Ruby API (if it exists) instead of running an OS command. In other words, use internal language features instead of invoking commands that can be exploited.
- If the use of user input is unavoidable, create an allowlist for inputs, such as allowed arguments.
- Strip everything except alphanumeric characters from an input provided for the command string and arguments.

#### Semgrep rule

<LinkToRegistryRule ruleId="ruby.lang.security.dangerous-subshell.dangerous-subshell" />

### 1.F. Using Process to execute OS commands

TODO: `spawn` and `exec`

https://ruby-doc.org/3.2.1/Process.html

Example:

```ruby
# safe
Process.spawn("ls -alh")
Process.spawn("ls", "-alh")
Process.spawn(["ls", "-alh"])

# vulnerable
user_input = ' && cat /etc/passwd' # Value supplied by user
Process.spawn("ls #{user_input}")

# safe
Process.exec("ls -alh")
Process.exec("ls", "-alh")
Process.exec(["ls", "-alh"])

# vulnerable
user_input = ' && cat /etc/passwd' # Value supplied by user
Process.exec("ls #{user_input}")
```

#### References

- [Process documentation](https://ruby-doc.org/3.2.1/Process.html)

#### Mitigation

- Do not provide raw user input to `%x` methods.
- Always try to use internal Ruby API (if it exists) instead of running an OS command. In other words, use internal language features instead of invoking commands that can be exploited.
- If the use of user input is unavoidable, create an allowlist for inputs, such as allowed arguments.
- Strip everything except alphanumeric characters from an input provided for the command string and arguments.

#### Semgrep rule

<LinkToRegistryRule ruleId="ruby.lang.security.dangerous-subshell.dangerous-subshell" />

### 1.F. Using PTY to execute OS commands

TODO: `spawn`

https://ruby-doc.org/3.2.1/exts/pty/PTY.html

Example:

```ruby
# safe
stdout,stdin,pid = PTY.spawn("ls -lah")

# vulnerable
user_input = ' && cat /etc/passwd' # Value supplied by user
stdout,stdin,pid = PTY.spawn("ls #{user_input}")
```

#### References

- [Process documentation](https://ruby-doc.org/3.2.1/Process.html)

#### Mitigation

- Do not provide raw user input to `%x` methods.
- Always try to use internal Ruby API (if it exists) instead of running an OS command. In other words, use internal language features instead of invoking commands that can be exploited.
- If the use of user input is unavoidable, create an allowlist for inputs, such as allowed arguments.
- Strip everything except alphanumeric characters from an input provided for the command string and arguments.

#### Semgrep rule

<LinkToRegistryRule ruleId="ruby.lang.security.dangerous-subshell.dangerous-subshell" />