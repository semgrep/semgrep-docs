---
description: Generate various Python lock files to run Semgrep Supply Chain scans successfully.
tags:
  - Semgrep Supply Chain
  - Python
  - Knowledge Base
  - Lock files
  - requirements.txt
  - Pipfile.lock
  - Poetry.lock
---

# Generating Python lock files for Semgrep Supply Chain scans

Python has different mechanisms to detect all packages used in a project. 

Semgrep Supply Chain can use any of the following methods to correctly parse your dependencies and detect vulnerabilities:

* `requirements.txt`
* `Pipfile.lock`
* Poetry
You can use these three ways (requirements.txt, Pipfile.lock, Poetry) to get a successful semgrep supply-chain scan.

## Generating requirements.txt from requirements.in

The file requirements.txt is the most common file to declare all the package dependencies.
The easy way to generate this file is having a requirements.in file with the direct Python packages (not transitive packages), and then using pip-tools to generate the requirements.txt file:

```bash
pip3 install pip-tools   
pip-compile -o requirements.txt
`````

It generates a requirements.txt file with direct and transitive dependencies.
For example, for this [project](https://github.com/sebastianrevuelta/binder-examples/) the requirements.in file looks like this:
```
numpy
matplotlib==3.*
seaborn==0.10.1
pandas
```

When executing the command:
```
pip-compile -o requirements.txt
```
It generates a requirements.txt that looks like this:
````
#
# This file is autogenerated by pip-compile with Python 3.10
# by the following command:
#
#    pip-compile --output-file=requirements.txt
#
contourpy==1.0.7
    # via matplotlib
cycler==0.11.0
    # via matplotlib
fonttools==4.39.4
    # via matplotlib
kiwisolver==1.4.4
    # via matplotlib
matplotlib==3.7.1
    # via
    #   -r requirements.in
    #   seaborn
numpy==1.24.3
    # via
    #   -r requirements.in
    #   contourpy
    #   matplotlib
    #   pandas
    #   scipy
    #   seaborn
packaging==23.1
    # via matplotlib
pandas==2.0.2
    # via
    #   -r requirements.in
    #   seaborn
pillow==9.5.0
    # via matplotlib
pyparsing==3.0.9
    # via matplotlib
python-dateutil==2.8.2
    # via
    #   matplotlib
    #   pandas
pytz==2023.3
    # via pandas
scipy==1.10.1
    # via seaborn
seaborn==0.10.1
    # via -r requirements.in
six==1.16.0
    # via python-dateutil
tzdata==2023.3
    # via pandas
````

This file has all dependencies needed for your project and can be used by Semgrep as an entry point for the Supply Chain scan.

## Generating requirements.txt with pip freeze

Pip freeze utility takes dependencies from packages already installed in your current environment. 
So the command:
````
pip freeze
````
must be executed in an isolated environment or a [virtual environment](https://docs.python.org/3/library/venv.html).
If you have a setup.py file and execute the following commands in an isolated environment:
`````
pip3 install .
pip freeze --all > tee requirements.txt
`````
Then you will have a requirements.txt with all the packages (direct/transitive) your project needs.

## Generating requirements.txt and scanning with Semgrep

So, now we can integrate this generation step before calling to semgrep supply-chain scan.
In the following example (a GitHub Action workflow), there are two jobs:
* First Job: Generation of requirements.txt file and upload it as an artifact
* Second Job: Download this artifact and scan it with Semgrep

``````
on:
  pull_request: {}
  workflow_dispatch: {}
  push:
    branches:
    - master
    paths:
    - .github/workflows/semgrep.yml
  schedule:
    - cron: '0 1 * * 0'
name: Semgrep
jobs:
  my_first_job: 
    name: requirementsGeneration
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Generate requirements txt
        run: |
          pip3 install pip-tools
          pip-compile -o requirements.txt
      - name: Upload Requirements File as Artifact
        uses: actions/upload-artifact@v3
        with:
          name: requirementstxt
          path: requirements.txt
  my_second_job:
    needs: my_first_job
    name: Scan
    runs-on: ubuntu-20.04
    env:
      SEMGREP_APP_TOKEN: ${{ secrets.SEMGREP_APP_TOKEN }}
    container:
      image: returntocorp/semgrep
    steps:
      - uses: actions/checkout@v3
      - name: Download artifact from previous job
        uses: actions/download-artifact@v3
        with:
          name: requirementstxt
      - run: semgrep ci --supply-chain

```````

## How to generate Pipfile.lock file.

Another exciting way to get a lock file is to use Pipfile.
The first step must be to declare a Pipfile with your direct dependencies:

It can look like this:
`````
[[source]]
url = "https://pypi.org/simple"
verify_ssl = true
name = "pypi"

[packages]
flasgger = "==0.9.5"
flask = "==2.2.2"
flask-cors = "==3.0.10"
marshmallow = "==3.18.0"
requests = "==2.25.1"
sqlalchemy = "==1.4.41"
waitress = "==2.1.2"
psycopg2 = "==2.9.5"
defusedxml = "==0.7.1"

[dev-packages]

[requires]
python_version = "3.9"
`````

Once done, you can generate a Pipfile.lock file with the following commands:
`````
pip install pipenv --user
pipenv lock
`````

The newly generated Pipfile.lock is a json file with all Python dependencies (direct/transitive) and their sha256 code.
The beginning of the file can look like this:

`````
{
    "_meta": {
        "hash": {
            "sha256": "af0d5c3f87bd23f340a214b12ad766ca83aead0c462aa08dbc4f012ac2796708"
        },
        "pipfile-spec": 6,
        "requires": {
            "python_version": "3.9"
        },
        "sources": [
            {
                "name": "pypi",
                "url": "https://pypi.org/simple",
                "verify_ssl": true
            }
        ]
    },
    "default": {
        "attrs": {
            "hashes": [
                "sha256:1f28b4522cdc2fb4256ac1a020c78acf9cba2c6b461ccd2c126f3aa8e8335d04",
                "sha256:6279836d581513a26f1bf235f9acd333bc9115683f14f7e8fae46c98fc50e015"
            ],
            "markers": "python_version >= '3.7'",
            "version": "==23.1.0"
        },
`````

## Poetry

[Poetry](https://python-poetry.org/) is a new tool for dependency management and packaging in Python.
It makes life easier from a Python dependencies point of view.
The key file here is one called: pyproject.toml, in that file, you can describe your dependencies.
It can look like this:

```````
[build-system]
requires = ["poetry-core>=1.1.0"]
build-backend = "poetry.core.masonry.api"

[tool.poetry]
name = "example-project"
version = "1.0.0"
description = "An example project"
authors = ["Your Name <yourname@example.com>"]

[tool.poetry.dependencies]
python = "^3.9"
requests = "^2.25.1"
numpy = "^1.21.0"

[tool.poetry.dev-dependencies]
pytest = "^6.2.4"
flake8 = "^3.9.2"

[build-system]
requires = ["poetry-core>=1.0.0"]
build-backend = "poetry.core.masonry.api"
````````

Then to generate a valid input for semgrep supply chain, you can execute the following:
```````
poetry lock
```````
this command generates a Poetry.lock file with all dependencies (direct/transitive) the project uses.

## What happens if I have some lock files but want to use only one in Semgrep Supply Chain scans?

There may already be a lock file in the repo (example Pipfile.lock), but I want to generate a new one (example requirements.txt) to be sure it has the latest dependencies.
In Semgrep, you can use the flag --include to specify only one entry point:

``````
semgrep --supply-chain --include=requirements.txt
```````

Or there is already a requirements.txt file in the repo, but you want to generate a fresh and updated version.
You can do it, but when running a semgrep scan, you will then see the following error:
```````
[ERROR] Found pending changes in tracked files. Baseline scans runs require a clean git state.
````````
Because the error is due to some git conflicts between requirements.txt that is already in the repo and the one the job generates each time.

A solution to that can be to generate the requirements.txt file in a specific folder (SSC, for example), so you can use only this file in the semgrep scan:

``````
semgrep --supply-chain --include=ssc/requirements.txt
```````

## Conclusions

There are several ways to get lock files with Python dependencies. Depending on your preferences, you can select one or another. The thing to keep in mind is to be sure it is generated before the semgrep scan and with the proper environment (we don't want a scan with all Python dependencies of your system, only the one used by your project)